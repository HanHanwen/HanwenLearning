# Introduction

​	Apache Flink提供了一种容错机制，可以一致地恢复数据流应用程序的状态。 该机制确保即使出现故障，程序的状态最终也将恰好一次反映出数据流中的每条记录。 请注意，有一个开关可以至少将担保降级一次（如下所述）。

​	容错机制连续绘制分布式流数据流的快照。 对于状态小的流应用程序，这些快照非常轻巧，可以在不影响性能的情况下频繁绘制。 流应用程序的状态存储在可配置的位置（例如主节点或HDFS）。

​	如果发生程序故障（由于机器，网络或软件故障），Flink将停止分布式数据流。 然后，系统重新启动操作员，并将他们重置为最新的成功检查点。 输入流将重置为状态快照的点。 **确保作为重新启动的并行数据流的一部分处理的任何记录都不属于先前的检查点状态。**

​	

注意：

​	1.默认状态下，checkpointing是禁用的；

​	2.为了使该机制实现其全部保证，数据流源（例如消息队列或代理）需要能够将流后退到定义的最近点；Apache Kafka具有此功能。

​	3.由于flink的checkpoint是通过分布式快照（snapshot）实现的，因此我们可以交替使用checkpoint和snapshot。



## Checkpointing

​	Flink容错机制的核心部分是绘制分布式数据流和操作员状态的一致快照。这些快照（snapshot）充当一致的检查点，如果发生故障，系统可以回退到这些检查点。



### Barriers

​	Flink的分布式快照的核心要素是流障碍（barriers）。这些壁垒（barrisrs）将注入到数据流中，并与记录一起作为数据流的一部分流动。Barriers从不超越记录本身，它们严格按照序列排列。Barrier将数据流中的记录分为进入当前快照的**记录集**和进入下一个快照的**记录集**。每个Barrier都包含快照ID，快照的记录已推送到快照的前面。Barrier不会中断流的流动，因此非常轻便。来自不同snapshot的多个barrier可以同时出现在流中，这意味着各种snapshot可能同时发生。

![Checkpoint barriers in data streams](../../picture/stream_barriers-20200119155431605.svg)



​	流Barrier在流源处注入并行数据流中。 快照n的barrier被注入的点（简称为Sn）是快照中覆盖数据的源流中的位置。 例如，在Apache Kafka中，此位置将是分区中最后一条记录的偏移量。 此位置Sn将报告给检查点协调员（Flink的JobManager）。

​	然后，barrier向下游流动。当中间操作员从其所有输入流中收到快照n的barrier时，它会将快照n的barrier的发送到其他所有输出流中。接收器运算符（流式DAG的末尾）从其所有输入流中接受到barrier n后，便将快照n确认给检查点协调器。在所有接收器都确认快照后，就认为快照已完成。

​	一旦**快照n完成**，该作业将不再向源请求Sn之前的记录，因为此时这些记录（及其后代记录）将通过整个数据流拓扑。





![Aligning data streams at operators with multiple inputs](../../picture/stream_aligning.svg)

​	接收多个输入流的操作员需要在快照屏障上对齐输入流。 上图说明了这一点：

> 操作员一旦从传入流中接受到快照barrier n，就无法处理改流中的任何其他记录，知道它也从其他输入接收到barrier n为止。否则，它将混合属于快照n的记录和属于快照n+1的记录。

> 报告barrier n的流被暂时搁置，从这些流接收的记录不会被处理，而是放入输入缓冲区中。

> 一旦最后一个流接收到barrier n，操作员将发出所有未决的传出记录，然后自身发出快照n的barrier。

> 之后，它将恢复处理所有输入流中的记录，处理输入缓冲中的记录，然后再处理流中的记录。



### State

​	当运算符包含任何形式的状态时，该状态也必须是快照的一部分。 操作员状态以不同的形式出现：

> User-defined State：这是由转换函数（例如map()或filter()）直接创建和修改的状态

> System state：此状态是指作为操作员计算的一部分的数据缓冲区。这种状态的一个典型事例就是window buffers。系统在其中收集（汇总）窗口的记录，知道评估并逐出窗口为止。

​	操作员在从输入流接收到所有快照屏障的时间点，以及向输出流发出barrier之前，对其状态进行快照。届时，将对进行barrier之前的记录进行状态的所有更新，并且不应用依赖于barrier后的记录进行任何更新。由于快照的状态可能很大，因此将其存储在可配置的状态后端中。默认情况下，这事JobManager的内存，但对于生产用途，应配置分布式可靠存储（如：hdfs）。在存储状态之后，操作员确认检查点，将快照barrier发送到输出流中，然后继续。

​	现在生成的快照包含：

> 对于每个并行流数据源，快照启动时流中的偏移量/位置

> 对于每个运算符，指向作为快照一部分存储的状态的指针

![Illustration of the Checkpointing Mechanism](../../picture/checkpointing.svg)





### Exactly Once vs. At Least Once

​	对齐步骤可以向流传输程序增加等待时间。通常，这种额外的延迟大约是几毫秒，但是我们已经看到一些异常值的延迟显著增加的情况。对于要求所有记录始终具有超低等待时间（几毫秒）的应用程序，Flink具有一个开关，可在checkpoint期间跳过流对齐。一旦操作员从每个输入中看到检查点障碍，仍然会绘制checkpoint snapshot。

​	跳过对齐之后，即使到达检查点n的某些checkpoint barrier，操作员仍会继续处理所有输入。这样，操作员还可以在获取检查点n的状态快照之前处理属于检查点n+1的元素。在还原时，这些记录将作为重复记录出现，因为它们都包含在检查点n的状态快照中，并且将在检查点n之后作为数据的一部分重播。





# Checkpointing